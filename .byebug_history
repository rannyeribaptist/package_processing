continue
result
continue
2 * 8.99
pack.value
pack
exit
result
continue
exit
highest_result
exit
continue
pack
continue
pack
exit
result.data
pack
pack.value
continue
pack.value * pack_object.quantity
pack.value
continue
pack.value * pack_object.quantity
pack.value
exit
result.data.map{|a| a.value.to_s + '|' + a.quantity.to_s}
exit
result.data
exit
result
result.map{|pack| pack.quantity.to_s + 'x' + pack.unities.to_s}
result
continue
result.data.sort_by(&:unities)
result.data
result
continue
result
continue
result.data.sort_by(&:unities).select{|a|a.quantity > 0}
result.data.sort_by(&:unities)
result.data
result
exit
result.data.select{|pk| pk.unities <= missing_unities}
result.data.select{|pk| pk.unities <= missining_unities}
result.data
missing_unities
pack
count_package(pack, missing_unities)
next
count_package(pack, missing_unities)
missing_unities
exit
result
next
result.data.first.quantity > 0
result.data.first
continue
result
continue
result.data.first.quantity > 0
result.data.first
result.data
exit
pack
continue
pack
continue
pack
continue
pack
continue
pack
continue
pack
continue
result
continue
result
continue
result
continue
pack
continue
pack
continue
result
continue
pack
continue
pack
exit
packs
continue
packs
continue
packs
continue
packs
continue
packs
continue
packs
continue
packs
continue
packs
continue
packs
continue
packs
continue
packs
continue
packs
continue
packs
continue
packs
continue
packs
continue
packs.data
packs
continue
result
continue
packs.data
continue
result
exit
result
continue
result
exit
packs.data.each{|a| p a}
packs.data
packs
continue
result
exit
exot
result.data.each{|a| p a}
result.data.each do |a|
result.data.each do |something|
result.data.eacj do |something|
result.data.sort_by do |something|
result.data.sort_by |something|
result.data
result.data.sort_by{|a|a.unities}
result.data
exit
result.data.sort{|i| i.unities}
result.data.sort(&:unities)
result.data.sort
result.data.first.unities
result.data.first
result.data.sort_by("unities")
result.data.sort_by(:unities)
result.data.sort_by(&[:unities])
result.data.sort_by(&:unities)
result.data
result
exit
result.data
result
next
exit
highest_result
continue
packs.data.map{|pack| pack[:unities] * pack[:quantity]}.sum
packs.data.map{|pack| pack[:unities]}
packs.data.map{|pack| pack.unities}
packs.data
packs
next
continue
pack.data.map{|pack| pack.unities * pack.quantity}.sum
pack.data.map{|pack| pack.unities * pack.quantity}
pack.data.map{|pack| pack.quantity}
pack.data.map{|pack| pack.unities}
pack.data.map{|pack| pack}
pack.data
pack
quantity
continue
highest_result.data
highest_result
exit
highest_result
highest_result.data
exit
highest_result.data
highest_result
continue
next
highest_result
continue
result
exit
EXIT
packs
result
pack == packs.last
continue
pack == packs.last
pack
pack_object
skip
continue
quantity >= pack.unities
next
pack_object.quantity
exit
pack_object.quantity
pack_object
next
pack_object
next
exit
packs.last.unities > 10
packs.last.unities
quantity
next
result
highest_result
next
highest_result
next
exit
packs.last.unities.to_i >= 10
packs.last.unities >= 10
quantity
packs.last.unities >= quantity
packs.last.unities
skip
next
continue
next
packs.first.value
packs
